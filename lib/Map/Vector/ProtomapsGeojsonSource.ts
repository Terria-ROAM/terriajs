import Point from "@mapbox/point-geometry";
import { featureCollection } from "@turf/helpers";
import geojsonvt from "geojson-vt";
import { makeObservable, observable, runInAction } from "mobx";
import {
  Bbox,
  GeomType,
  Feature as ProtomapsFeature,
  TileSource,
  Zxy
} from "protomaps-leaflet";
import {
  FeatureCollectionWithCrs,
  toFeatureCollection
} from "../../ModelMixins/GeojsonMixin";
import {
  PROTOMAPS_DEFAULT_TILE_SIZE,
  PROTOMAPS_TILE_BUFFER
} from "../ImageryProvider/ProtomapsImageryProvider";

/** Extent (of coordinates) of tiles generated by geojson-vt */
const GEOJSON_VT_EXTENT = 4096;

/** Layer name to use with geojson-vt
 *  This must be used in PaintRules/LabelRules (eg `dataLayer: "layer"`)
 */
export const GEOJSON_SOURCE_LAYER_NAME = "layer";

/** Protomaps Geojson source
 * This source uses geojson-vt to tile geojson data
 * It is designed to be used with ProtomapsImageryProvider
 */
export class ProtomapsGeojsonSource implements TileSource {
  /** Data object from Options */
  private readonly data: string | FeatureCollectionWithCrs;

  /** Resolved geojsonObject (if applicable) */
  @observable.ref
  geojsonObject: FeatureCollectionWithCrs | undefined;

  /** Geojson-vt tileIndex (if applicable) */
  tileIndex: Promise<ReturnType<typeof geojsonvt>> | undefined;

  constructor(url: string | FeatureCollectionWithCrs) {
    makeObservable(this);
    this.data = url;
    if (typeof url !== "string") {
      this.geojsonObject = url;
    }
  }

  /** Fetch geoJSON data (if required) and tile with geojson-vt */
  private async fetchData() {
    let result: FeatureCollectionWithCrs;
    if (typeof this.data === "string") {
      result =
        toFeatureCollection(await (await fetch(this.data)).json()) ??
        featureCollection([]);
    } else {
      result = this.data;
    }

    runInAction(() => (this.geojsonObject = result));

    return geojsonvt(result as geojsonvt.Data, {
      buffer:
        (PROTOMAPS_TILE_BUFFER / PROTOMAPS_DEFAULT_TILE_SIZE) *
        GEOJSON_VT_EXTENT,
      extent: GEOJSON_VT_EXTENT,
      maxZoom: 24
    });
  }

  public async get(
    c: Zxy,
    tileSize: number
  ): Promise<Map<string, ProtomapsFeature[]>> {
    if (!this.tileIndex) {
      this.tileIndex = this.fetchData();
    }

    // request a particular tile
    const tile = (await this.tileIndex).getTile(c.z, c.x, c.y);
    const result = new Map<string, ProtomapsFeature[]>();

    if (tile && tile.features && tile.features.length > 0) {
      result.set(
        GEOJSON_SOURCE_LAYER_NAME,
        geojsonVtTileToProtomapsFeatures(tile.features, tileSize)
      );
    }

    return result;
  }
}

export const geomTypeMap = (
  type: string | null | undefined
): GeomType | null => {
  switch (type) {
    case "Point":
    case "MultiPoint":
      return GeomType.Point;
    case "LineString":
    case "MultiLineString":
      return GeomType.Line;
    case "Polygon":
    case "MultiPolygon":
      return GeomType.Polygon;
    default:
      return null;
  }
};

export function geojsonVtTileToProtomapsFeatures(
  features: geojsonvt.Feature[],
  tileSize: number
): ProtomapsFeature[] {
  const scale = tileSize / GEOJSON_VT_EXTENT;

  return features
    .map((f) => {
      let transformedGeom: Point[][] = [];
      let numVertices = 0;

      // Calculate bbox
      const bbox: Bbox = {
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };

      // Multi-polygon
      if (Array.isArray(f.geometry[0][0])) {
        // Note: the type is incorrect here
        const geom = f.geometry as unknown as [number, number][][];
        transformedGeom = geom.map((g1) =>
          g1.map((g2) => {
            const x = g2[0] * scale;
            const y = g2[1] * scale;

            if (bbox.minX > x) {
              bbox.minX = x;
            }

            if (bbox.maxX < x) {
              bbox.maxX = x;
            }

            if (bbox.minY > y) {
              bbox.minY = y;
            }

            if (bbox.maxY < y) {
              bbox.maxY = y;
            }
            return new Point(x, y);
          })
        );
        numVertices = transformedGeom.reduce<number>(
          (count, current) => count + current.length,
          0
        );
      }
      // Other feature types
      else {
        const geom = f.geometry as [number, number][];
        transformedGeom = [
          geom.map((g1) => {
            const x = g1[0] * scale;
            const y = g1[1] * scale;

            if (bbox.minX > x) {
              bbox.minX = x;
            }

            if (bbox.maxX < x) {
              bbox.maxX = x;
            }

            if (bbox.minY > y) {
              bbox.minY = y;
            }

            if (bbox.maxY < y) {
              bbox.maxY = y;
            }
            return new Point(x, y);
          })
        ];
        numVertices = transformedGeom.length;
      }

      if (f.type === 0) return null;

      const geomType = {
        [1]: GeomType.Point,
        [2]: GeomType.Line,
        [3]: GeomType.Polygon
      }[f.type];

      const feature: ProtomapsFeature = {
        props: { ...(f.tags ?? {}) },
        bbox,
        geomType,
        geom: transformedGeom,
        numVertices
      };

      return feature;
    })
    .filter((f): f is ProtomapsFeature => f !== null);
}
